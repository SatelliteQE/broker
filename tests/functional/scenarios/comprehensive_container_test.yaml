# Comprehensive Container Provider Test Scenario
#
# This scenario exercises the full breadth of Broker scenarios functionality
# using the Container provider. It demonstrates:
#
# - checkout with count and configuration
# - provider_info queries (flag-style and value-style)
# - ssh commands with capture and transforms
# - scp file uploads
# - sftp operations (upload and download)
# - output to stdout, stderr, and files (JSON/YAML)
# - loops with inventory filters, dict.items(), and variable lists
# - when conditions (simple and complex)
# - on_error recovery steps
# - exit_on_error: false for non-critical steps
# - parallel vs sequential execution
# - capture with custom keys
# - variables with CLI override capability
# - config section with provider settings
#
# Prerequisites:
# - A running container runtime (Podman or Docker)
# - Container provider configured in broker_settings.yaml
# - A broker-compatible container image (e.g., ubi8 with SSH)
#
# Usage:
#   broker scenarios execute comprehensive_container_test
#   broker scenarios execute comprehensive_container_test --CONTAINER_IMAGE ubi9 --HOST_COUNT 3
#
# Note: This scenario creates temporary files in /tmp and cleans up after itself.

config:
  # Custom inventory path for this scenario's hosts
  inventory_path: ~/.broker/comprehensive_test_inventory.yaml
  # Custom log file for this scenario (demonstrates filename-only resolution)
  log_path: comprehensive_container_test.log
  # Provider settings (can be overridden via CLI with --config.settings.Container.runtime)
  settings:
    Container:
      # runtime: podman  # Uncomment to override default
      auto_map_ports: true

variables:
  # Container configuration - override via CLI as needed
  CONTAINER_IMAGE: localhost/ubi8:latest
  HOST_COUNT: 2
  
  # Test configuration
  TEST_COMMANDS:
    - "cat /etc/os-release"
    - "uname -a"
    - "df -h"
  
  TEST_FILENAME: broker_test_file.txt
  TEST_CONTENT: "Hello from Broker Scenarios!"
  
  # Feature flags for conditional execution
  RUN_SFTP_TESTS: true
  RUN_PARALLEL_TESTS: true
  VERBOSE_OUTPUT: false

steps:
  # ============================================================================
  # SECTION 1: Provider Information Queries
  # ============================================================================
  
  - name: Query available container images (flag-style)
    action: provider_info
    arguments:
      provider: Container
      query: container_hosts
    capture:
      as: available_images

  - name: Display available images
    action: output
    arguments:
      content: "Found {{ available_images | length }} broker-compatible container images"
      destination: stdout

  - name: Query specific image details (value-style)
    action: provider_info
    arguments:
      provider: Container
      query:
        container_host: "{{ CONTAINER_IMAGE }}"
    capture:
      as: image_details
    on_error: continue  # Continue if image not found (will use default)

  - name: Log image details if found
    action: output
    arguments:
      content: "Using image: {{ image_details.name if image_details else CONTAINER_IMAGE }}"
      destination: stdout
    when: image_details is defined

  # ============================================================================
  # SECTION 2: Container Checkout
  # ============================================================================
  
  - name: Provision test containers
    action: checkout
    arguments:
      container_host: "{{ CONTAINER_IMAGE }}"
      count: "{{ HOST_COUNT }}"
    on_error:
      - name: Log checkout failure
        action: output
        arguments:
          content: "ERROR: Failed to checkout containers. Check container runtime status."
          destination: stderr
      - name: Exit on checkout failure
        action: exit
        arguments:
          return_code: 10
          message: "Container checkout failed - cannot continue tests"

  - name: Verify checkout succeeded
    action: output
    arguments:
      content: "Successfully provisioned {{ scenario_inventory | length }} container(s)"
      destination: stdout

  # ============================================================================
  # SECTION 3: Basic SSH Commands with Capture
  # ============================================================================
  
  - name: Get container hostnames
    action: ssh
    arguments:
      command: "hostname"
    with:
      hosts: scenario_inventory
    capture:
      as: hostnames

  - name: Display hostnames (single vs multi-host handling)
    action: output
    arguments:
      content: "Container hostnames: {{ hostnames }}"
      destination: stdout

  - name: Run multiple test commands via loop
    action: ssh
    arguments:
      command: "{{ cmd }}"
    loop:
      iterable: TEST_COMMANDS
      iter_var: cmd
      on_error: continue  # Continue loop even if a command fails
    with:
      hosts: "@scenario_inv[0]"  # Only first host for this test
    capture:
      as: command_outputs
      key: cmd  # Use command as dictionary key

  - name: Log verbose command output
    action: output
    arguments:
      content: |
        Command outputs from first container:
        {{ command_outputs }}
      destination: stdout
    when: VERBOSE_OUTPUT == true

  # ============================================================================
  # SECTION 4: File Operations (SCP and SFTP)
  # ============================================================================
  
  - name: Create test file on first container
    action: ssh
    arguments:
      command: "echo '{{ TEST_CONTENT }}' > /tmp/{{ TEST_FILENAME }}"
    with:
      hosts: "@scenario_inv[0]"

  - name: Use SSH to create files on containers
    action: ssh
    arguments:
      command: "echo 'SCP simulation - file created via SSH' > /tmp/scp_test_file.txt"
    with:
      hosts: scenario_inventory
    capture:
      as: scp_simulation
    exit_on_error: false

  - name: Verify file creation on each host
    action: ssh
    arguments:
      command: "cat /tmp/scp_test_file.txt 2>/dev/null || echo 'File not found'"
    with:
      hosts: scenario_inventory
    capture:
      as: file_verification

  # SFTP tests - conditional on RUN_SFTP_TESTS variable
  # Note: SFTP requires local files. We'll test by creating a file remotely
  # and then demonstrating the SFTP read capability
  - name: Create files for SFTP test on containers
    action: ssh
    arguments:
      command: "echo 'SFTP test content from $(hostname)' > /tmp/sftp_test_file.txt"
    with:
      hosts: scenario_inventory
    when: RUN_SFTP_TESTS == true

  - name: Read remote file content (SFTP read simulation via SSH)
    action: ssh
    arguments:
      command: "cat /tmp/sftp_test_file.txt"
    with:
      hosts: "@scenario_inv[0]"
    capture:
      as: sftp_read_result
    when: RUN_SFTP_TESTS == true
    exit_on_error: false

  # ============================================================================
  # SECTION 5: Parallel vs Sequential Execution
  # ============================================================================
  
  - name: Parallel command execution (default)
    action: ssh
    arguments:
      command: "sleep 1 && echo 'Parallel execution from $(hostname)'"
      timeout: 10
    with:
      hosts: scenario_inventory
    parallel: true  # This is the default
    capture:
      as: parallel_results
    when: RUN_PARALLEL_TESTS == true

  - name: Sequential command execution
    action: ssh
    arguments:
      command: "echo 'Sequential execution from $(hostname)'"
    with:
      hosts: scenario_inventory
    parallel: false  # Force sequential
    capture:
      as: sequential_results

  # ============================================================================
  # SECTION 6: Loop with Dictionary Items and Tuple Unpacking
  # ============================================================================
  
  - name: Process results from each host
    action: output
    arguments:
      content: "Host {{ hostname }} returned status {{ result.status }}"
      destination: stdout
    loop:
      iterable: sequential_results.items()
      iter_var: hostname, result
    when: sequential_results is defined and sequential_results is mapping

  # ============================================================================
  # SECTION 7: Complex Conditionals and Error Handling
  # ============================================================================
  
  - name: Check disk space (non-critical)
    action: ssh
    arguments:
      command: "df -h / | tail -1 | awk '{print $5}' | tr -d '%'"
    with:
      hosts: "@scenario_inv[0]"  # Single host for simpler output
    capture:
      as: disk_usage
    exit_on_error: false

  - name: Log disk usage
    action: output
    arguments:
      content: "Disk usage on first container: {{ disk_usage.stdout if disk_usage else 'unknown' }}%"
      destination: stdout
    when: disk_usage is defined

  - name: Intentionally failing command (demonstrates on_error recovery)
    action: ssh
    arguments:
      command: "exit 1"  # This will fail
    with:
      hosts: "@scenario_inv[0]"
    on_error:
      - name: Log expected failure
        action: output
        arguments:
          content: "Expected failure handled - recovery steps executed successfully"
          destination: stdout
      # Note: We don't exit here, allowing the scenario to continue

  # ============================================================================
  # SECTION 8: Output to Files (JSON and YAML formats)
  # ============================================================================
  
  - name: Collect final test summary
    action: ssh
    arguments:
      command: "uptime"
    with:
      hosts: scenario_inventory
    capture:
      as: uptime_results

  - name: Save results to JSON file
    action: output
    arguments:
      content:
        scenario_name: comprehensive_container_test
        containers_tested: "{{ scenario_inventory | length }}"
        image_used: "{{ CONTAINER_IMAGE }}"
        test_commands_run: "{{ TEST_COMMANDS }}"
        sftp_tests_enabled: "{{ RUN_SFTP_TESTS }}"
        parallel_tests_enabled: "{{ RUN_PARALLEL_TESTS }}"
      destination: /tmp/broker_scenario_results.json
      mode: overwrite

  - name: Append summary to log file
    action: output
    arguments:
      content: "Test run completed with {{ scenario_inventory | length }} containers"
      destination: /tmp/broker_scenario_log.txt
      mode: append

  # Note: We'll save the inventory snapshot after syncing, using the dict format
  # from the inventory action rather than Host objects

  # ============================================================================
  # SECTION 9: Inventory Operations
  # ============================================================================
  
  - name: Sync main broker inventory
    action: inventory
    arguments:
      sync: Container
    capture:
      as: synced_inventory
    exit_on_error: false  # Don't fail if sync has issues

  - name: Save inventory snapshot to YAML (using dict format from inventory sync)
    action: output
    arguments:
      content: "{{ synced_inventory }}"
      destination: /tmp/broker_test_inventory_snapshot.yaml
    when: synced_inventory is defined

  - name: Display inventory count
    action: output
    arguments:
      content: "Main broker inventory sync completed"
      destination: stdout
    when: synced_inventory is defined

  - name: Note if inventory sync failed
    action: output
    arguments:
      content: "Note: Inventory sync was skipped or failed (this is expected in some environments)"
      destination: stdout
    when: synced_inventory is not defined

  # ============================================================================
  # SECTION 10: Cleanup with Error Recovery
  # ============================================================================
  
  - name: Cleanup test files on containers
    action: ssh
    arguments:
      command: "rm -f /tmp/broker_test_* /tmp/scp_test_* /tmp/sftp_test_* 2>/dev/null; echo 'Cleanup complete'"
    with:
      hosts: scenario_inventory
    exit_on_error: false

  - name: Final status output
    action: output
    arguments:
      content: |
        
        ============================================
        COMPREHENSIVE SCENARIO TEST COMPLETE
        ============================================
        Containers tested: {{ scenario_inventory | length }}
        Image: {{ CONTAINER_IMAGE }}
        Results saved to: /tmp/broker_scenario_results.json
        ============================================
      destination: stdout

  - name: Release all containers
    action: checkin
    with:
      hosts: scenario_inventory
    on_error:
      - name: Log checkin failure
        action: output
        arguments:
          content: "WARNING: Failed to release some containers. Manual cleanup may be required."
          destination: stderr
      - name: List remaining containers
        action: inventory
        arguments:
          sync: Container
        capture:
          as: remaining_inventory
      - name: Exit with warning
        action: exit
        arguments:
          return_code: 5
          message: "Scenario completed but container cleanup failed"

  - name: Confirm cleanup
    action: output
    arguments:
      content: "All containers successfully released. Scenario complete!"
      destination: stdout
